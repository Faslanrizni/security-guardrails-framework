#!/usr/bin/env python3
"""
AI Code Detector
Identifies AI-generated code using multiple heuristics
"""

import os
import re
import math
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional
from collections import Counter
import argparse


class AICodeDetector:
    """
    Detects AI-generated code using multiple techniques:
    - Commit message analysis
    - Code pattern matching
    - Entropy calculation
    - Comment density analysis
    """
    
    def __init__(self, repo_path: str = "."):
        self.repo_path = Path(repo_path)
        self.findings = []
        
        # AI indicators in commit messages
        self.ai_commit_patterns = [
            r'generated by',
            r'created by AI',
            r'via Copilot',
            r'using ChatGPT',
            r'with Claude',
            r'AI-assisted',
            r'copilot generated',
            r'gemini generated',
        ]
        
        # AI code patterns (things AI often generates)
        self.ai_code_patterns = [
            # Generic placeholder names
            r'function\s+\w+\s*\(\s*\)\s*{\s*}\s*$',  # Empty function
            r'class\s+\w+\s*:\s*pass',  # Empty Python class
            r'//\s*TODO.*implement',
            r'#\s*TODO.*implement',
            r'return\s+null;?\s*$',
            r'throw new NotImplementedException',
            r'raise NotImplementedError',
            
            # AI-style comments (verbose explanations)
            r'// This function (does|will|is used to)',
            r'# This function (does|will|is used to)',
            r'// The purpose of this',
            r'# The purpose of this',
            
            # AI signatures
            r'Generated by (Copilot|ChatGPT|Claude|Gemini)',
            r'Created with assistance from',
        ]
        
        # File extensions to scan
        self.scan_extensions = [
            '.py', '.js', '.ts', '.java', '.go', '.rb',
            '.php', '.c', '.cpp', '.h', '.cs', '.swift'
        ]
    
    def scan_commit(self, commit_hash: str = "HEAD") -> List[Dict]:
        """
        Scan the latest commit for AI-generated code
        """
        print("\nðŸ¤– Scanning for AI-generated code...")
        
        # Get commit info
        commit_info = self._get_commit_info(commit_hash)
        if not commit_info:
            print("  âš ï¸ Could not get commit info")
            return []
        
        print(f"  ðŸ” Debug: Commit message: {commit_info['message'][:50]}...")
        
        # Analyze commit message
        message_score = self._analyze_commit_message(commit_info['message'])
        if message_score > 0.3:
            self.findings.append({
                'type': 'commit_message',
                'confidence': message_score,
                'details': 'Commit message suggests AI generation',
                'value': commit_info['message'][:100]
            })
        
        # Get changed files
        files = self._get_changed_files(commit_hash)
        
        if not files:
            print("  âš ï¸ No files found in commit")
            return []
        
        print(f"  ðŸ” Debug: Scanning {len(files)} files...")
        
        for file_path in files:
            print(f"  ðŸ” Debug: Checking file: {file_path}")
            
            # Check if file should be scanned
            if not self._should_scan_file(file_path):
                print(f"  ðŸ” Debug: Skipping {file_path} (extension not in scan list)")
                continue
                
            full_path = self.repo_path / file_path
            if not full_path.exists():
                print(f"  ðŸ” Debug: File {file_path} doesn't exist")
                continue
            
            # Analyze file content
            file_score, indicators = self._analyze_file_content(full_path)
            print(f"  ðŸ” Debug: File score: {file_score}")
            
            if file_score > 0.4:
                self.findings.append({
                    'file': file_path,
                    'type': 'file_content',
                    'confidence': file_score,
                    'indicators': indicators,
                    'requires_review': file_score > 0.7
                })
        
        self._print_report()
        return self.findings
    
    def _should_scan_file(self, file_path: str) -> bool:
        """Check if file should be scanned based on extension"""
        ext = Path(file_path).suffix.lower()
        return ext in self.scan_extensions
    
    def _get_commit_info(self, commit_hash: str) -> Dict:
        """Get commit message and metadata"""
        try:
            import subprocess
            result = subprocess.run(
                ['git', 'show', '-s', '--format=%s%n%b', commit_hash],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            return {
                'message': result.stdout.strip(),
                'hash': commit_hash
            }
        except:
            return {}
    
    def _get_changed_files(self, commit_hash: str) -> List[str]:
        """Get files changed in commit"""
        try:
            import subprocess
            print(f"  ðŸ” Debug: Getting files for commit {commit_hash}")
            
            result = subprocess.run(
                ['git', 'diff-tree', '--no-commit-id', '--name-only', '-r', commit_hash],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            
            files = result.stdout.strip().split('\n') if result.stdout.strip() else []
            print(f"  ðŸ” Debug: Found {len(files)} files: {files}")
            
            return files
        except Exception as e:
            print(f"  ðŸ” Debug: Error getting files: {e}")
            return []
    
    def _analyze_commit_message(self, message: str) -> float:
        """Analyze commit message for AI indicators"""
        score = 0.0
        message_lower = message.lower()
        
        # Check for explicit AI mentions
        for pattern in self.ai_commit_patterns:
            if re.search(pattern, message_lower):
                score += 0.4
                break
        
        # Check message length (AI messages are often longer)
        words = len(message.split())
        if words > 50:
            score += 0.2
        elif words < 5:
            score -= 0.1  # Too short, probably human
        
        # Check for markdown formatting (AI loves markdown)
        if '**' in message or '*' in message or '#' in message:
            score += 0.1
        
        # Check for bullet points
        if '- ' in message or '* ' in message:
            score += 0.1
        
        return min(score, 1.0)
    
    def _analyze_file_content(self, file_path: Path) -> tuple:
        """Analyze file content for AI indicators"""
        score = 0.0
        indicators = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            # Check for explicit AI generation comments
            for pattern in self.ai_code_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    score += 0.3
                    indicators.append("AI signature comment")
                    break
            
            # Check comment density (AI comments heavily)
            comment_count = len(re.findall(r'//|#|\*|"""|\'\'\'', content))
            total_lines = len(lines)
            comment_ratio = comment_count / total_lines if total_lines > 0 else 0
            
            if comment_ratio > 0.4:
                score += 0.2
                indicators.append("High comment density")
            elif comment_ratio < 0.05:
                score -= 0.1  # Too few comments, probably human
            
            # Check for repetitive patterns (AI often repeats)
            line_counter = Counter([l.strip() for l in lines if l.strip()])
            most_common = line_counter.most_common(1)
            if most_common and most_common[0][1] > 10:
                score += 0.2
                indicators.append("Repetitive code patterns")
            
            # Check function count (AI generates many small functions)
            function_matches = re.findall(r'(def |function |func |class )', content)
            if len(function_matches) > 10:
                score += 0.1
                indicators.append("Many small functions/classes")
            
            # Entropy check (AI code often has higher entropy)
            entropy = self._calculate_entropy(content)
            if entropy > 4.5:
                score += 0.1
                indicators.append("High entropy (unusual character distribution)")
            
            # Check for placeholder names
            placeholder_patterns = [
                r'var\s+foo',
                r'var\s+bar',
                r'function\s+temp',
                r'class\s+Example',
                r'MyFunction',
                r'TestClass'
            ]
            
            for pattern in placeholder_patterns:
                if re.search(pattern, content):
                    score += 0.1
                    indicators.append("Placeholder names")
                    break
            
        except Exception as e:
            print(f"  âš ï¸ Error analyzing {file_path}: {e}")
        
        return min(score, 1.0), indicators
    
    def _calculate_entropy(self, text: str) -> float:
        """Calculate Shannon entropy of text"""
        if not text:
            return 0
        
        # Count character frequencies
        freq = {}
        for char in text:
            freq[char] = freq.get(char, 0) + 1
        
        # Calculate entropy
        entropy = 0
        text_len = len(text)
        for count in freq.values():
            prob = count / text_len
            if prob > 0:
                entropy -= prob * math.log2(prob)
        
        return entropy
    
    def _print_report(self):
        """Print detection report"""
        if not self.findings:
            print("âœ… No AI-generated code detected")
            return
        
        print(f"\nðŸ¤– AI CODE DETECTION RESULTS")
        print("=" * 60)
        
        requires_review = [f for f in self.findings if f.get('requires_review')]
        others = [f for f in self.findings if not f.get('requires_review')]
        
        if requires_review:
            print(f"\nðŸ”´ REQUIRES EXTRA REVIEW ({len(requires_review)})")
            for f in requires_review:
                if 'file' in f:
                    print(f"\n  ðŸ“„ {f['file']}")
                    print(f"  Confidence: {f['confidence']:.2f}")
                    if f.get('indicators'):
                        print(f"  Indicators: {', '.join(f['indicators'][:3])}")
                else:
                    print(f"\n  ðŸ“ Commit message")
                    print(f"  Confidence: {f['confidence']:.2f}")
                    print(f"  Details: {f['details']}")
        
        if others:
            print(f"\nâšª POSSIBLE AI ({len(others)})")
            for f in others:
                if 'file' in f:
                    print(f"  {f['file']} (confidence: {f['confidence']:.2f})")
                else:
                    print(f"  Commit message flagged (confidence: {f['confidence']:.2f})")
    
    def should_block(self) -> bool:
        """Check if findings should block merge"""
        return any(f.get('requires_review') for f in self.findings)


def main():
    """CLI entry point"""
    parser = argparse.ArgumentParser(description="Detect AI-generated code")
    parser.add_argument("--repo-path", default=".", help="Path to repository")
    parser.add_argument("--commit", default="HEAD", help="Commit to scan")
    parser.add_argument("--block", action="store_true", help="Block if AI detected")
    args = parser.parse_args()
    
    detector = AICodeDetector(args.repo_path)
    findings = detector.scan_commit(args.commit)
    
    if args.block and detector.should_block():
        print("\nðŸš¨ AI-GENERATED CODE REQUIRES REVIEW - BLOCKING")
        sys.exit(1)
    
    sys.exit(0)


if __name__ == "__main__":
    main()